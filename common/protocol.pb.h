// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "msg.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto;
namespace XuMQ {
class basicAckRequest;
struct basicAckRequestDefaultTypeInternal;
extern basicAckRequestDefaultTypeInternal _basicAckRequest_default_instance_;
class basicCancelRequest;
struct basicCancelRequestDefaultTypeInternal;
extern basicCancelRequestDefaultTypeInternal _basicCancelRequest_default_instance_;
class basicConsumeRequest;
struct basicConsumeRequestDefaultTypeInternal;
extern basicConsumeRequestDefaultTypeInternal _basicConsumeRequest_default_instance_;
class basicConsumeResponse;
struct basicConsumeResponseDefaultTypeInternal;
extern basicConsumeResponseDefaultTypeInternal _basicConsumeResponse_default_instance_;
class basicPublishRequest;
struct basicPublishRequestDefaultTypeInternal;
extern basicPublishRequestDefaultTypeInternal _basicPublishRequest_default_instance_;
class basicResponse;
struct basicResponseDefaultTypeInternal;
extern basicResponseDefaultTypeInternal _basicResponse_default_instance_;
class closeChannelRequest;
struct closeChannelRequestDefaultTypeInternal;
extern closeChannelRequestDefaultTypeInternal _closeChannelRequest_default_instance_;
class declareExchangeRequest;
struct declareExchangeRequestDefaultTypeInternal;
extern declareExchangeRequestDefaultTypeInternal _declareExchangeRequest_default_instance_;
class declareExchangeRequest_ArgsEntry_DoNotUse;
struct declareExchangeRequest_ArgsEntry_DoNotUseDefaultTypeInternal;
extern declareExchangeRequest_ArgsEntry_DoNotUseDefaultTypeInternal _declareExchangeRequest_ArgsEntry_DoNotUse_default_instance_;
class declareQueueRequest;
struct declareQueueRequestDefaultTypeInternal;
extern declareQueueRequestDefaultTypeInternal _declareQueueRequest_default_instance_;
class declareQueueRequest_ArgsEntry_DoNotUse;
struct declareQueueRequest_ArgsEntry_DoNotUseDefaultTypeInternal;
extern declareQueueRequest_ArgsEntry_DoNotUseDefaultTypeInternal _declareQueueRequest_ArgsEntry_DoNotUse_default_instance_;
class deleteExchangeRequest;
struct deleteExchangeRequestDefaultTypeInternal;
extern deleteExchangeRequestDefaultTypeInternal _deleteExchangeRequest_default_instance_;
class deleteQueueRequest;
struct deleteQueueRequestDefaultTypeInternal;
extern deleteQueueRequestDefaultTypeInternal _deleteQueueRequest_default_instance_;
class openChannelRequest;
struct openChannelRequestDefaultTypeInternal;
extern openChannelRequestDefaultTypeInternal _openChannelRequest_default_instance_;
class queueBindRequest;
struct queueBindRequestDefaultTypeInternal;
extern queueBindRequestDefaultTypeInternal _queueBindRequest_default_instance_;
class queueUnBindRequest;
struct queueUnBindRequestDefaultTypeInternal;
extern queueUnBindRequestDefaultTypeInternal _queueUnBindRequest_default_instance_;
}  // namespace XuMQ
PROTOBUF_NAMESPACE_OPEN
template<> ::XuMQ::basicAckRequest* Arena::CreateMaybeMessage<::XuMQ::basicAckRequest>(Arena*);
template<> ::XuMQ::basicCancelRequest* Arena::CreateMaybeMessage<::XuMQ::basicCancelRequest>(Arena*);
template<> ::XuMQ::basicConsumeRequest* Arena::CreateMaybeMessage<::XuMQ::basicConsumeRequest>(Arena*);
template<> ::XuMQ::basicConsumeResponse* Arena::CreateMaybeMessage<::XuMQ::basicConsumeResponse>(Arena*);
template<> ::XuMQ::basicPublishRequest* Arena::CreateMaybeMessage<::XuMQ::basicPublishRequest>(Arena*);
template<> ::XuMQ::basicResponse* Arena::CreateMaybeMessage<::XuMQ::basicResponse>(Arena*);
template<> ::XuMQ::closeChannelRequest* Arena::CreateMaybeMessage<::XuMQ::closeChannelRequest>(Arena*);
template<> ::XuMQ::declareExchangeRequest* Arena::CreateMaybeMessage<::XuMQ::declareExchangeRequest>(Arena*);
template<> ::XuMQ::declareExchangeRequest_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::XuMQ::declareExchangeRequest_ArgsEntry_DoNotUse>(Arena*);
template<> ::XuMQ::declareQueueRequest* Arena::CreateMaybeMessage<::XuMQ::declareQueueRequest>(Arena*);
template<> ::XuMQ::declareQueueRequest_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::XuMQ::declareQueueRequest_ArgsEntry_DoNotUse>(Arena*);
template<> ::XuMQ::deleteExchangeRequest* Arena::CreateMaybeMessage<::XuMQ::deleteExchangeRequest>(Arena*);
template<> ::XuMQ::deleteQueueRequest* Arena::CreateMaybeMessage<::XuMQ::deleteQueueRequest>(Arena*);
template<> ::XuMQ::openChannelRequest* Arena::CreateMaybeMessage<::XuMQ::openChannelRequest>(Arena*);
template<> ::XuMQ::queueBindRequest* Arena::CreateMaybeMessage<::XuMQ::queueBindRequest>(Arena*);
template<> ::XuMQ::queueUnBindRequest* Arena::CreateMaybeMessage<::XuMQ::queueUnBindRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace XuMQ {

// ===================================================================

class openChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.openChannelRequest) */ {
 public:
  inline openChannelRequest() : openChannelRequest(nullptr) {}
  ~openChannelRequest() override;
  explicit PROTOBUF_CONSTEXPR openChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  openChannelRequest(const openChannelRequest& from);
  openChannelRequest(openChannelRequest&& from) noexcept
    : openChannelRequest() {
    *this = ::std::move(from);
  }

  inline openChannelRequest& operator=(const openChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline openChannelRequest& operator=(openChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const openChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const openChannelRequest* internal_default_instance() {
    return reinterpret_cast<const openChannelRequest*>(
               &_openChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(openChannelRequest& a, openChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(openChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(openChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  openChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<openChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const openChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const openChannelRequest& from) {
    openChannelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(openChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.openChannelRequest";
  }
  protected:
  explicit openChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.openChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class closeChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.closeChannelRequest) */ {
 public:
  inline closeChannelRequest() : closeChannelRequest(nullptr) {}
  ~closeChannelRequest() override;
  explicit PROTOBUF_CONSTEXPR closeChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  closeChannelRequest(const closeChannelRequest& from);
  closeChannelRequest(closeChannelRequest&& from) noexcept
    : closeChannelRequest() {
    *this = ::std::move(from);
  }

  inline closeChannelRequest& operator=(const closeChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline closeChannelRequest& operator=(closeChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const closeChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const closeChannelRequest* internal_default_instance() {
    return reinterpret_cast<const closeChannelRequest*>(
               &_closeChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(closeChannelRequest& a, closeChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(closeChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(closeChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  closeChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<closeChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const closeChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const closeChannelRequest& from) {
    closeChannelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(closeChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.closeChannelRequest";
  }
  protected:
  explicit closeChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.closeChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class declareExchangeRequest_ArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareExchangeRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareExchangeRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  declareExchangeRequest_ArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR declareExchangeRequest_ArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit declareExchangeRequest_ArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const declareExchangeRequest_ArgsEntry_DoNotUse& other);
  static const declareExchangeRequest_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const declareExchangeRequest_ArgsEntry_DoNotUse*>(&_declareExchangeRequest_ArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "XuMQ.declareExchangeRequest.ArgsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "XuMQ.declareExchangeRequest.ArgsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protocol_2eproto;
};

// -------------------------------------------------------------------

class declareExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.declareExchangeRequest) */ {
 public:
  inline declareExchangeRequest() : declareExchangeRequest(nullptr) {}
  ~declareExchangeRequest() override;
  explicit PROTOBUF_CONSTEXPR declareExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  declareExchangeRequest(const declareExchangeRequest& from);
  declareExchangeRequest(declareExchangeRequest&& from) noexcept
    : declareExchangeRequest() {
    *this = ::std::move(from);
  }

  inline declareExchangeRequest& operator=(const declareExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline declareExchangeRequest& operator=(declareExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const declareExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const declareExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const declareExchangeRequest*>(
               &_declareExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(declareExchangeRequest& a, declareExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(declareExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(declareExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  declareExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<declareExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const declareExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const declareExchangeRequest& from) {
    declareExchangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(declareExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.declareExchangeRequest";
  }
  protected:
  explicit declareExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 7,
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kExchangeTypeFieldNumber = 4,
    kDurableFieldNumber = 5,
    kAutoDeleteFieldNumber = 6,
  };
  // map<string, string> args = 7;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_args();

  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // .XuMQ.ExchangeType exchange_type = 4;
  void clear_exchange_type();
  ::XuMQ::ExchangeType exchange_type() const;
  void set_exchange_type(::XuMQ::ExchangeType value);
  private:
  ::XuMQ::ExchangeType _internal_exchange_type() const;
  void _internal_set_exchange_type(::XuMQ::ExchangeType value);
  public:

  // bool durable = 5;
  void clear_durable();
  bool durable() const;
  void set_durable(bool value);
  private:
  bool _internal_durable() const;
  void _internal_set_durable(bool value);
  public:

  // bool auto_delete = 6;
  void clear_auto_delete();
  bool auto_delete() const;
  void set_auto_delete(bool value);
  private:
  bool _internal_auto_delete() const;
  void _internal_set_auto_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.declareExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        declareExchangeRequest_ArgsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
    int exchange_type_;
    bool durable_;
    bool auto_delete_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class deleteExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.deleteExchangeRequest) */ {
 public:
  inline deleteExchangeRequest() : deleteExchangeRequest(nullptr) {}
  ~deleteExchangeRequest() override;
  explicit PROTOBUF_CONSTEXPR deleteExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteExchangeRequest(const deleteExchangeRequest& from);
  deleteExchangeRequest(deleteExchangeRequest&& from) noexcept
    : deleteExchangeRequest() {
    *this = ::std::move(from);
  }

  inline deleteExchangeRequest& operator=(const deleteExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteExchangeRequest& operator=(deleteExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const deleteExchangeRequest*>(
               &_deleteExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(deleteExchangeRequest& a, deleteExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteExchangeRequest& from) {
    deleteExchangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.deleteExchangeRequest";
  }
  protected:
  explicit deleteExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.deleteExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class declareQueueRequest_ArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareQueueRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareQueueRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  declareQueueRequest_ArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR declareQueueRequest_ArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit declareQueueRequest_ArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const declareQueueRequest_ArgsEntry_DoNotUse& other);
  static const declareQueueRequest_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const declareQueueRequest_ArgsEntry_DoNotUse*>(&_declareQueueRequest_ArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "XuMQ.declareQueueRequest.ArgsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "XuMQ.declareQueueRequest.ArgsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protocol_2eproto;
};

// -------------------------------------------------------------------

class declareQueueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.declareQueueRequest) */ {
 public:
  inline declareQueueRequest() : declareQueueRequest(nullptr) {}
  ~declareQueueRequest() override;
  explicit PROTOBUF_CONSTEXPR declareQueueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  declareQueueRequest(const declareQueueRequest& from);
  declareQueueRequest(declareQueueRequest&& from) noexcept
    : declareQueueRequest() {
    *this = ::std::move(from);
  }

  inline declareQueueRequest& operator=(const declareQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline declareQueueRequest& operator=(declareQueueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const declareQueueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const declareQueueRequest* internal_default_instance() {
    return reinterpret_cast<const declareQueueRequest*>(
               &_declareQueueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(declareQueueRequest& a, declareQueueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(declareQueueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(declareQueueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  declareQueueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<declareQueueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const declareQueueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const declareQueueRequest& from) {
    declareQueueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(declareQueueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.declareQueueRequest";
  }
  protected:
  explicit declareQueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 7,
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kQueueNameFieldNumber = 3,
    kExclusiveFieldNumber = 4,
    kDurableFieldNumber = 5,
    kAutoDeleteFieldNumber = 6,
  };
  // map<string, string> args = 7;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_args();

  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string queue_name = 3;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // bool exclusive = 4;
  void clear_exclusive();
  bool exclusive() const;
  void set_exclusive(bool value);
  private:
  bool _internal_exclusive() const;
  void _internal_set_exclusive(bool value);
  public:

  // bool durable = 5;
  void clear_durable();
  bool durable() const;
  void set_durable(bool value);
  private:
  bool _internal_durable() const;
  void _internal_set_durable(bool value);
  public:

  // bool auto_delete = 6;
  void clear_auto_delete();
  bool auto_delete() const;
  void set_auto_delete(bool value);
  private:
  bool _internal_auto_delete() const;
  void _internal_set_auto_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.declareQueueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        declareQueueRequest_ArgsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    bool exclusive_;
    bool durable_;
    bool auto_delete_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class deleteQueueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.deleteQueueRequest) */ {
 public:
  inline deleteQueueRequest() : deleteQueueRequest(nullptr) {}
  ~deleteQueueRequest() override;
  explicit PROTOBUF_CONSTEXPR deleteQueueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteQueueRequest(const deleteQueueRequest& from);
  deleteQueueRequest(deleteQueueRequest&& from) noexcept
    : deleteQueueRequest() {
    *this = ::std::move(from);
  }

  inline deleteQueueRequest& operator=(const deleteQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteQueueRequest& operator=(deleteQueueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteQueueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteQueueRequest* internal_default_instance() {
    return reinterpret_cast<const deleteQueueRequest*>(
               &_deleteQueueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(deleteQueueRequest& a, deleteQueueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteQueueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteQueueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteQueueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteQueueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteQueueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteQueueRequest& from) {
    deleteQueueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteQueueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.deleteQueueRequest";
  }
  protected:
  explicit deleteQueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kQueueNameFieldNumber = 3,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string queue_name = 3;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.deleteQueueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class queueBindRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.queueBindRequest) */ {
 public:
  inline queueBindRequest() : queueBindRequest(nullptr) {}
  ~queueBindRequest() override;
  explicit PROTOBUF_CONSTEXPR queueBindRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  queueBindRequest(const queueBindRequest& from);
  queueBindRequest(queueBindRequest&& from) noexcept
    : queueBindRequest() {
    *this = ::std::move(from);
  }

  inline queueBindRequest& operator=(const queueBindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline queueBindRequest& operator=(queueBindRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const queueBindRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const queueBindRequest* internal_default_instance() {
    return reinterpret_cast<const queueBindRequest*>(
               &_queueBindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(queueBindRequest& a, queueBindRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(queueBindRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(queueBindRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  queueBindRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<queueBindRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const queueBindRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const queueBindRequest& from) {
    queueBindRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(queueBindRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.queueBindRequest";
  }
  protected:
  explicit queueBindRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kQueueNameFieldNumber = 4,
    kBindingKeyFieldNumber = 5,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // string binding_key = 5;
  void clear_binding_key();
  const std::string& binding_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binding_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binding_key();
  PROTOBUF_NODISCARD std::string* release_binding_key();
  void set_allocated_binding_key(std::string* binding_key);
  private:
  const std::string& _internal_binding_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binding_key(const std::string& value);
  std::string* _internal_mutable_binding_key();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.queueBindRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binding_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class queueUnBindRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.queueUnBindRequest) */ {
 public:
  inline queueUnBindRequest() : queueUnBindRequest(nullptr) {}
  ~queueUnBindRequest() override;
  explicit PROTOBUF_CONSTEXPR queueUnBindRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  queueUnBindRequest(const queueUnBindRequest& from);
  queueUnBindRequest(queueUnBindRequest&& from) noexcept
    : queueUnBindRequest() {
    *this = ::std::move(from);
  }

  inline queueUnBindRequest& operator=(const queueUnBindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline queueUnBindRequest& operator=(queueUnBindRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const queueUnBindRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const queueUnBindRequest* internal_default_instance() {
    return reinterpret_cast<const queueUnBindRequest*>(
               &_queueUnBindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(queueUnBindRequest& a, queueUnBindRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(queueUnBindRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(queueUnBindRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  queueUnBindRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<queueUnBindRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const queueUnBindRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const queueUnBindRequest& from) {
    queueUnBindRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(queueUnBindRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.queueUnBindRequest";
  }
  protected:
  explicit queueUnBindRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kQueueNameFieldNumber = 4,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.queueUnBindRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicPublishRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.basicPublishRequest) */ {
 public:
  inline basicPublishRequest() : basicPublishRequest(nullptr) {}
  ~basicPublishRequest() override;
  explicit PROTOBUF_CONSTEXPR basicPublishRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicPublishRequest(const basicPublishRequest& from);
  basicPublishRequest(basicPublishRequest&& from) noexcept
    : basicPublishRequest() {
    *this = ::std::move(from);
  }

  inline basicPublishRequest& operator=(const basicPublishRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicPublishRequest& operator=(basicPublishRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicPublishRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicPublishRequest* internal_default_instance() {
    return reinterpret_cast<const basicPublishRequest*>(
               &_basicPublishRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(basicPublishRequest& a, basicPublishRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicPublishRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicPublishRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicPublishRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicPublishRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicPublishRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const basicPublishRequest& from) {
    basicPublishRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicPublishRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.basicPublishRequest";
  }
  protected:
  explicit basicPublishRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kBodyFieldNumber = 4,
    kPropertiesFieldNumber = 5,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // string body = 4;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // .XuMQ.BasicProperties properties = 5;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::XuMQ::BasicProperties& properties() const;
  PROTOBUF_NODISCARD ::XuMQ::BasicProperties* release_properties();
  ::XuMQ::BasicProperties* mutable_properties();
  void set_allocated_properties(::XuMQ::BasicProperties* properties);
  private:
  const ::XuMQ::BasicProperties& _internal_properties() const;
  ::XuMQ::BasicProperties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::XuMQ::BasicProperties* properties);
  ::XuMQ::BasicProperties* unsafe_arena_release_properties();

  // @@protoc_insertion_point(class_scope:XuMQ.basicPublishRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::XuMQ::BasicProperties* properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicAckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.basicAckRequest) */ {
 public:
  inline basicAckRequest() : basicAckRequest(nullptr) {}
  ~basicAckRequest() override;
  explicit PROTOBUF_CONSTEXPR basicAckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicAckRequest(const basicAckRequest& from);
  basicAckRequest(basicAckRequest&& from) noexcept
    : basicAckRequest() {
    *this = ::std::move(from);
  }

  inline basicAckRequest& operator=(const basicAckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicAckRequest& operator=(basicAckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicAckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicAckRequest* internal_default_instance() {
    return reinterpret_cast<const basicAckRequest*>(
               &_basicAckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(basicAckRequest& a, basicAckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicAckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicAckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicAckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicAckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicAckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const basicAckRequest& from) {
    basicAckRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicAckRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.basicAckRequest";
  }
  protected:
  explicit basicAckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kQueueNameFieldNumber = 3,
    kMsgIdFieldNumber = 4,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string queue_name = 3;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // string msg_id = 4;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.basicAckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicConsumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.basicConsumeRequest) */ {
 public:
  inline basicConsumeRequest() : basicConsumeRequest(nullptr) {}
  ~basicConsumeRequest() override;
  explicit PROTOBUF_CONSTEXPR basicConsumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicConsumeRequest(const basicConsumeRequest& from);
  basicConsumeRequest(basicConsumeRequest&& from) noexcept
    : basicConsumeRequest() {
    *this = ::std::move(from);
  }

  inline basicConsumeRequest& operator=(const basicConsumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicConsumeRequest& operator=(basicConsumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicConsumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicConsumeRequest* internal_default_instance() {
    return reinterpret_cast<const basicConsumeRequest*>(
               &_basicConsumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(basicConsumeRequest& a, basicConsumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicConsumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicConsumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicConsumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicConsumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicConsumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const basicConsumeRequest& from) {
    basicConsumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicConsumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.basicConsumeRequest";
  }
  protected:
  explicit basicConsumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kConsumerTagFieldNumber = 3,
    kQueueNameFieldNumber = 4,
    kAutoAckFieldNumber = 5,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string consumer_tag = 3;
  void clear_consumer_tag();
  const std::string& consumer_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumer_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumer_tag();
  PROTOBUF_NODISCARD std::string* release_consumer_tag();
  void set_allocated_consumer_tag(std::string* consumer_tag);
  private:
  const std::string& _internal_consumer_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_tag(const std::string& value);
  std::string* _internal_mutable_consumer_tag();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // bool auto_ack = 5;
  void clear_auto_ack();
  bool auto_ack() const;
  void set_auto_ack(bool value);
  private:
  bool _internal_auto_ack() const;
  void _internal_set_auto_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.basicConsumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    bool auto_ack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicCancelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.basicCancelRequest) */ {
 public:
  inline basicCancelRequest() : basicCancelRequest(nullptr) {}
  ~basicCancelRequest() override;
  explicit PROTOBUF_CONSTEXPR basicCancelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicCancelRequest(const basicCancelRequest& from);
  basicCancelRequest(basicCancelRequest&& from) noexcept
    : basicCancelRequest() {
    *this = ::std::move(from);
  }

  inline basicCancelRequest& operator=(const basicCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicCancelRequest& operator=(basicCancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicCancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicCancelRequest* internal_default_instance() {
    return reinterpret_cast<const basicCancelRequest*>(
               &_basicCancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(basicCancelRequest& a, basicCancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicCancelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicCancelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicCancelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicCancelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicCancelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const basicCancelRequest& from) {
    basicCancelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicCancelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.basicCancelRequest";
  }
  protected:
  explicit basicCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kConsumerTagFieldNumber = 3,
    kQueueNameFieldNumber = 4,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string consumer_tag = 3;
  void clear_consumer_tag();
  const std::string& consumer_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumer_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumer_tag();
  PROTOBUF_NODISCARD std::string* release_consumer_tag();
  void set_allocated_consumer_tag(std::string* consumer_tag);
  private:
  const std::string& _internal_consumer_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_tag(const std::string& value);
  std::string* _internal_mutable_consumer_tag();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.basicCancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicConsumeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.basicConsumeResponse) */ {
 public:
  inline basicConsumeResponse() : basicConsumeResponse(nullptr) {}
  ~basicConsumeResponse() override;
  explicit PROTOBUF_CONSTEXPR basicConsumeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicConsumeResponse(const basicConsumeResponse& from);
  basicConsumeResponse(basicConsumeResponse&& from) noexcept
    : basicConsumeResponse() {
    *this = ::std::move(from);
  }

  inline basicConsumeResponse& operator=(const basicConsumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicConsumeResponse& operator=(basicConsumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicConsumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicConsumeResponse* internal_default_instance() {
    return reinterpret_cast<const basicConsumeResponse*>(
               &_basicConsumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(basicConsumeResponse& a, basicConsumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(basicConsumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicConsumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicConsumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicConsumeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicConsumeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const basicConsumeResponse& from) {
    basicConsumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicConsumeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.basicConsumeResponse";
  }
  protected:
  explicit basicConsumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCidFieldNumber = 1,
    kConsumerTagFieldNumber = 2,
    kBodyFieldNumber = 3,
    kPropertiesFieldNumber = 4,
  };
  // string cid = 1;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string consumer_tag = 2;
  void clear_consumer_tag();
  const std::string& consumer_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumer_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumer_tag();
  PROTOBUF_NODISCARD std::string* release_consumer_tag();
  void set_allocated_consumer_tag(std::string* consumer_tag);
  private:
  const std::string& _internal_consumer_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_tag(const std::string& value);
  std::string* _internal_mutable_consumer_tag();
  public:

  // string body = 3;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // .XuMQ.BasicProperties properties = 4;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::XuMQ::BasicProperties& properties() const;
  PROTOBUF_NODISCARD ::XuMQ::BasicProperties* release_properties();
  ::XuMQ::BasicProperties* mutable_properties();
  void set_allocated_properties(::XuMQ::BasicProperties* properties);
  private:
  const ::XuMQ::BasicProperties& _internal_properties() const;
  ::XuMQ::BasicProperties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::XuMQ::BasicProperties* properties);
  ::XuMQ::BasicProperties* unsafe_arena_release_properties();

  // @@protoc_insertion_point(class_scope:XuMQ.basicConsumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::XuMQ::BasicProperties* properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuMQ.basicResponse) */ {
 public:
  inline basicResponse() : basicResponse(nullptr) {}
  ~basicResponse() override;
  explicit PROTOBUF_CONSTEXPR basicResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicResponse(const basicResponse& from);
  basicResponse(basicResponse&& from) noexcept
    : basicResponse() {
    *this = ::std::move(from);
  }

  inline basicResponse& operator=(const basicResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicResponse& operator=(basicResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicResponse* internal_default_instance() {
    return reinterpret_cast<const basicResponse*>(
               &_basicResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(basicResponse& a, basicResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(basicResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const basicResponse& from) {
    basicResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuMQ.basicResponse";
  }
  protected:
  explicit basicResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kOkFieldNumber = 3,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // bool ok = 3;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XuMQ.basicResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// openChannelRequest

// string rid = 1;
inline void openChannelRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& openChannelRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.openChannelRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void openChannelRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.openChannelRequest.rid)
}
inline std::string* openChannelRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.openChannelRequest.rid)
  return _s;
}
inline const std::string& openChannelRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void openChannelRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* openChannelRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* openChannelRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.openChannelRequest.rid)
  return _impl_.rid_.Release();
}
inline void openChannelRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.openChannelRequest.rid)
}

// string cid = 2;
inline void openChannelRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& openChannelRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.openChannelRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void openChannelRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.openChannelRequest.cid)
}
inline std::string* openChannelRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.openChannelRequest.cid)
  return _s;
}
inline const std::string& openChannelRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void openChannelRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* openChannelRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* openChannelRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.openChannelRequest.cid)
  return _impl_.cid_.Release();
}
inline void openChannelRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.openChannelRequest.cid)
}

// -------------------------------------------------------------------

// closeChannelRequest

// string rid = 1;
inline void closeChannelRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& closeChannelRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.closeChannelRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void closeChannelRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.closeChannelRequest.rid)
}
inline std::string* closeChannelRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.closeChannelRequest.rid)
  return _s;
}
inline const std::string& closeChannelRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void closeChannelRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* closeChannelRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* closeChannelRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.closeChannelRequest.rid)
  return _impl_.rid_.Release();
}
inline void closeChannelRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.closeChannelRequest.rid)
}

// string cid = 2;
inline void closeChannelRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& closeChannelRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.closeChannelRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void closeChannelRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.closeChannelRequest.cid)
}
inline std::string* closeChannelRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.closeChannelRequest.cid)
  return _s;
}
inline const std::string& closeChannelRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void closeChannelRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* closeChannelRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* closeChannelRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.closeChannelRequest.cid)
  return _impl_.cid_.Release();
}
inline void closeChannelRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.closeChannelRequest.cid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// declareExchangeRequest

// string rid = 1;
inline void declareExchangeRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& declareExchangeRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareExchangeRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareExchangeRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.declareExchangeRequest.rid)
}
inline std::string* declareExchangeRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.declareExchangeRequest.rid)
  return _s;
}
inline const std::string& declareExchangeRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void declareExchangeRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.declareExchangeRequest.rid)
  return _impl_.rid_.Release();
}
inline void declareExchangeRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.declareExchangeRequest.rid)
}

// string cid = 2;
inline void declareExchangeRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& declareExchangeRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareExchangeRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareExchangeRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.declareExchangeRequest.cid)
}
inline std::string* declareExchangeRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.declareExchangeRequest.cid)
  return _s;
}
inline const std::string& declareExchangeRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void declareExchangeRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.declareExchangeRequest.cid)
  return _impl_.cid_.Release();
}
inline void declareExchangeRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.declareExchangeRequest.cid)
}

// string exchange_name = 3;
inline void declareExchangeRequest::clear_exchange_name() {
  _impl_.exchange_name_.ClearToEmpty();
}
inline const std::string& declareExchangeRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareExchangeRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareExchangeRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.declareExchangeRequest.exchange_name)
}
inline std::string* declareExchangeRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.declareExchangeRequest.exchange_name)
  return _s;
}
inline const std::string& declareExchangeRequest::_internal_exchange_name() const {
  return _impl_.exchange_name_.Get();
}
inline void declareExchangeRequest::_internal_set_exchange_name(const std::string& value) {
  
  _impl_.exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::_internal_mutable_exchange_name() {
  
  return _impl_.exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:XuMQ.declareExchangeRequest.exchange_name)
  return _impl_.exchange_name_.Release();
}
inline void declareExchangeRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_name_.IsDefault()) {
    _impl_.exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.declareExchangeRequest.exchange_name)
}

// .XuMQ.ExchangeType exchange_type = 4;
inline void declareExchangeRequest::clear_exchange_type() {
  _impl_.exchange_type_ = 0;
}
inline ::XuMQ::ExchangeType declareExchangeRequest::_internal_exchange_type() const {
  return static_cast< ::XuMQ::ExchangeType >(_impl_.exchange_type_);
}
inline ::XuMQ::ExchangeType declareExchangeRequest::exchange_type() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareExchangeRequest.exchange_type)
  return _internal_exchange_type();
}
inline void declareExchangeRequest::_internal_set_exchange_type(::XuMQ::ExchangeType value) {
  
  _impl_.exchange_type_ = value;
}
inline void declareExchangeRequest::set_exchange_type(::XuMQ::ExchangeType value) {
  _internal_set_exchange_type(value);
  // @@protoc_insertion_point(field_set:XuMQ.declareExchangeRequest.exchange_type)
}

// bool durable = 5;
inline void declareExchangeRequest::clear_durable() {
  _impl_.durable_ = false;
}
inline bool declareExchangeRequest::_internal_durable() const {
  return _impl_.durable_;
}
inline bool declareExchangeRequest::durable() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareExchangeRequest.durable)
  return _internal_durable();
}
inline void declareExchangeRequest::_internal_set_durable(bool value) {
  
  _impl_.durable_ = value;
}
inline void declareExchangeRequest::set_durable(bool value) {
  _internal_set_durable(value);
  // @@protoc_insertion_point(field_set:XuMQ.declareExchangeRequest.durable)
}

// bool auto_delete = 6;
inline void declareExchangeRequest::clear_auto_delete() {
  _impl_.auto_delete_ = false;
}
inline bool declareExchangeRequest::_internal_auto_delete() const {
  return _impl_.auto_delete_;
}
inline bool declareExchangeRequest::auto_delete() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareExchangeRequest.auto_delete)
  return _internal_auto_delete();
}
inline void declareExchangeRequest::_internal_set_auto_delete(bool value) {
  
  _impl_.auto_delete_ = value;
}
inline void declareExchangeRequest::set_auto_delete(bool value) {
  _internal_set_auto_delete(value);
  // @@protoc_insertion_point(field_set:XuMQ.declareExchangeRequest.auto_delete)
}

// map<string, string> args = 7;
inline int declareExchangeRequest::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int declareExchangeRequest::args_size() const {
  return _internal_args_size();
}
inline void declareExchangeRequest::clear_args() {
  _impl_.args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareExchangeRequest::_internal_args() const {
  return _impl_.args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareExchangeRequest::args() const {
  // @@protoc_insertion_point(field_map:XuMQ.declareExchangeRequest.args)
  return _internal_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareExchangeRequest::_internal_mutable_args() {
  return _impl_.args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareExchangeRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:XuMQ.declareExchangeRequest.args)
  return _internal_mutable_args();
}

// -------------------------------------------------------------------

// deleteExchangeRequest

// string rid = 1;
inline void deleteExchangeRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& deleteExchangeRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.deleteExchangeRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteExchangeRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.deleteExchangeRequest.rid)
}
inline std::string* deleteExchangeRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.deleteExchangeRequest.rid)
  return _s;
}
inline const std::string& deleteExchangeRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void deleteExchangeRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.deleteExchangeRequest.rid)
  return _impl_.rid_.Release();
}
inline void deleteExchangeRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.deleteExchangeRequest.rid)
}

// string cid = 2;
inline void deleteExchangeRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& deleteExchangeRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.deleteExchangeRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteExchangeRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.deleteExchangeRequest.cid)
}
inline std::string* deleteExchangeRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.deleteExchangeRequest.cid)
  return _s;
}
inline const std::string& deleteExchangeRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void deleteExchangeRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.deleteExchangeRequest.cid)
  return _impl_.cid_.Release();
}
inline void deleteExchangeRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.deleteExchangeRequest.cid)
}

// string exchange_name = 3;
inline void deleteExchangeRequest::clear_exchange_name() {
  _impl_.exchange_name_.ClearToEmpty();
}
inline const std::string& deleteExchangeRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.deleteExchangeRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteExchangeRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.deleteExchangeRequest.exchange_name)
}
inline std::string* deleteExchangeRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.deleteExchangeRequest.exchange_name)
  return _s;
}
inline const std::string& deleteExchangeRequest::_internal_exchange_name() const {
  return _impl_.exchange_name_.Get();
}
inline void deleteExchangeRequest::_internal_set_exchange_name(const std::string& value) {
  
  _impl_.exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::_internal_mutable_exchange_name() {
  
  return _impl_.exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:XuMQ.deleteExchangeRequest.exchange_name)
  return _impl_.exchange_name_.Release();
}
inline void deleteExchangeRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_name_.IsDefault()) {
    _impl_.exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.deleteExchangeRequest.exchange_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// declareQueueRequest

// string rid = 1;
inline void declareQueueRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& declareQueueRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareQueueRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareQueueRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.declareQueueRequest.rid)
}
inline std::string* declareQueueRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.declareQueueRequest.rid)
  return _s;
}
inline const std::string& declareQueueRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void declareQueueRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareQueueRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareQueueRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.declareQueueRequest.rid)
  return _impl_.rid_.Release();
}
inline void declareQueueRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.declareQueueRequest.rid)
}

// string cid = 2;
inline void declareQueueRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& declareQueueRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareQueueRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareQueueRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.declareQueueRequest.cid)
}
inline std::string* declareQueueRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.declareQueueRequest.cid)
  return _s;
}
inline const std::string& declareQueueRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void declareQueueRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareQueueRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareQueueRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.declareQueueRequest.cid)
  return _impl_.cid_.Release();
}
inline void declareQueueRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.declareQueueRequest.cid)
}

// string queue_name = 3;
inline void declareQueueRequest::clear_queue_name() {
  _impl_.queue_name_.ClearToEmpty();
}
inline const std::string& declareQueueRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareQueueRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareQueueRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.declareQueueRequest.queue_name)
}
inline std::string* declareQueueRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.declareQueueRequest.queue_name)
  return _s;
}
inline const std::string& declareQueueRequest::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void declareQueueRequest::_internal_set_queue_name(const std::string& value) {
  
  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* declareQueueRequest::_internal_mutable_queue_name() {
  
  return _impl_.queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* declareQueueRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:XuMQ.declareQueueRequest.queue_name)
  return _impl_.queue_name_.Release();
}
inline void declareQueueRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  _impl_.queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queue_name_.IsDefault()) {
    _impl_.queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.declareQueueRequest.queue_name)
}

// bool exclusive = 4;
inline void declareQueueRequest::clear_exclusive() {
  _impl_.exclusive_ = false;
}
inline bool declareQueueRequest::_internal_exclusive() const {
  return _impl_.exclusive_;
}
inline bool declareQueueRequest::exclusive() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareQueueRequest.exclusive)
  return _internal_exclusive();
}
inline void declareQueueRequest::_internal_set_exclusive(bool value) {
  
  _impl_.exclusive_ = value;
}
inline void declareQueueRequest::set_exclusive(bool value) {
  _internal_set_exclusive(value);
  // @@protoc_insertion_point(field_set:XuMQ.declareQueueRequest.exclusive)
}

// bool durable = 5;
inline void declareQueueRequest::clear_durable() {
  _impl_.durable_ = false;
}
inline bool declareQueueRequest::_internal_durable() const {
  return _impl_.durable_;
}
inline bool declareQueueRequest::durable() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareQueueRequest.durable)
  return _internal_durable();
}
inline void declareQueueRequest::_internal_set_durable(bool value) {
  
  _impl_.durable_ = value;
}
inline void declareQueueRequest::set_durable(bool value) {
  _internal_set_durable(value);
  // @@protoc_insertion_point(field_set:XuMQ.declareQueueRequest.durable)
}

// bool auto_delete = 6;
inline void declareQueueRequest::clear_auto_delete() {
  _impl_.auto_delete_ = false;
}
inline bool declareQueueRequest::_internal_auto_delete() const {
  return _impl_.auto_delete_;
}
inline bool declareQueueRequest::auto_delete() const {
  // @@protoc_insertion_point(field_get:XuMQ.declareQueueRequest.auto_delete)
  return _internal_auto_delete();
}
inline void declareQueueRequest::_internal_set_auto_delete(bool value) {
  
  _impl_.auto_delete_ = value;
}
inline void declareQueueRequest::set_auto_delete(bool value) {
  _internal_set_auto_delete(value);
  // @@protoc_insertion_point(field_set:XuMQ.declareQueueRequest.auto_delete)
}

// map<string, string> args = 7;
inline int declareQueueRequest::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int declareQueueRequest::args_size() const {
  return _internal_args_size();
}
inline void declareQueueRequest::clear_args() {
  _impl_.args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareQueueRequest::_internal_args() const {
  return _impl_.args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareQueueRequest::args() const {
  // @@protoc_insertion_point(field_map:XuMQ.declareQueueRequest.args)
  return _internal_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareQueueRequest::_internal_mutable_args() {
  return _impl_.args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareQueueRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:XuMQ.declareQueueRequest.args)
  return _internal_mutable_args();
}

// -------------------------------------------------------------------

// deleteQueueRequest

// string rid = 1;
inline void deleteQueueRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& deleteQueueRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.deleteQueueRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteQueueRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.deleteQueueRequest.rid)
}
inline std::string* deleteQueueRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.deleteQueueRequest.rid)
  return _s;
}
inline const std::string& deleteQueueRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void deleteQueueRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.deleteQueueRequest.rid)
  return _impl_.rid_.Release();
}
inline void deleteQueueRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.deleteQueueRequest.rid)
}

// string cid = 2;
inline void deleteQueueRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& deleteQueueRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.deleteQueueRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteQueueRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.deleteQueueRequest.cid)
}
inline std::string* deleteQueueRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.deleteQueueRequest.cid)
  return _s;
}
inline const std::string& deleteQueueRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void deleteQueueRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.deleteQueueRequest.cid)
  return _impl_.cid_.Release();
}
inline void deleteQueueRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.deleteQueueRequest.cid)
}

// string queue_name = 3;
inline void deleteQueueRequest::clear_queue_name() {
  _impl_.queue_name_.ClearToEmpty();
}
inline const std::string& deleteQueueRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.deleteQueueRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteQueueRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.deleteQueueRequest.queue_name)
}
inline std::string* deleteQueueRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.deleteQueueRequest.queue_name)
  return _s;
}
inline const std::string& deleteQueueRequest::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void deleteQueueRequest::_internal_set_queue_name(const std::string& value) {
  
  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::_internal_mutable_queue_name() {
  
  return _impl_.queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:XuMQ.deleteQueueRequest.queue_name)
  return _impl_.queue_name_.Release();
}
inline void deleteQueueRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  _impl_.queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queue_name_.IsDefault()) {
    _impl_.queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.deleteQueueRequest.queue_name)
}

// -------------------------------------------------------------------

// queueBindRequest

// string rid = 1;
inline void queueBindRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& queueBindRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueBindRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueBindRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueBindRequest.rid)
}
inline std::string* queueBindRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueBindRequest.rid)
  return _s;
}
inline const std::string& queueBindRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void queueBindRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* queueBindRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* queueBindRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.queueBindRequest.rid)
  return _impl_.rid_.Release();
}
inline void queueBindRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueBindRequest.rid)
}

// string cid = 2;
inline void queueBindRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& queueBindRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueBindRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueBindRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueBindRequest.cid)
}
inline std::string* queueBindRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueBindRequest.cid)
  return _s;
}
inline const std::string& queueBindRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void queueBindRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* queueBindRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* queueBindRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.queueBindRequest.cid)
  return _impl_.cid_.Release();
}
inline void queueBindRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueBindRequest.cid)
}

// string exchange_name = 3;
inline void queueBindRequest::clear_exchange_name() {
  _impl_.exchange_name_.ClearToEmpty();
}
inline const std::string& queueBindRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueBindRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueBindRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueBindRequest.exchange_name)
}
inline std::string* queueBindRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueBindRequest.exchange_name)
  return _s;
}
inline const std::string& queueBindRequest::_internal_exchange_name() const {
  return _impl_.exchange_name_.Get();
}
inline void queueBindRequest::_internal_set_exchange_name(const std::string& value) {
  
  _impl_.exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* queueBindRequest::_internal_mutable_exchange_name() {
  
  return _impl_.exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* queueBindRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:XuMQ.queueBindRequest.exchange_name)
  return _impl_.exchange_name_.Release();
}
inline void queueBindRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_name_.IsDefault()) {
    _impl_.exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueBindRequest.exchange_name)
}

// string queue_name = 4;
inline void queueBindRequest::clear_queue_name() {
  _impl_.queue_name_.ClearToEmpty();
}
inline const std::string& queueBindRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueBindRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueBindRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueBindRequest.queue_name)
}
inline std::string* queueBindRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueBindRequest.queue_name)
  return _s;
}
inline const std::string& queueBindRequest::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void queueBindRequest::_internal_set_queue_name(const std::string& value) {
  
  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* queueBindRequest::_internal_mutable_queue_name() {
  
  return _impl_.queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* queueBindRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:XuMQ.queueBindRequest.queue_name)
  return _impl_.queue_name_.Release();
}
inline void queueBindRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  _impl_.queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queue_name_.IsDefault()) {
    _impl_.queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueBindRequest.queue_name)
}

// string binding_key = 5;
inline void queueBindRequest::clear_binding_key() {
  _impl_.binding_key_.ClearToEmpty();
}
inline const std::string& queueBindRequest::binding_key() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueBindRequest.binding_key)
  return _internal_binding_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueBindRequest::set_binding_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.binding_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueBindRequest.binding_key)
}
inline std::string* queueBindRequest::mutable_binding_key() {
  std::string* _s = _internal_mutable_binding_key();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueBindRequest.binding_key)
  return _s;
}
inline const std::string& queueBindRequest::_internal_binding_key() const {
  return _impl_.binding_key_.Get();
}
inline void queueBindRequest::_internal_set_binding_key(const std::string& value) {
  
  _impl_.binding_key_.Set(value, GetArenaForAllocation());
}
inline std::string* queueBindRequest::_internal_mutable_binding_key() {
  
  return _impl_.binding_key_.Mutable(GetArenaForAllocation());
}
inline std::string* queueBindRequest::release_binding_key() {
  // @@protoc_insertion_point(field_release:XuMQ.queueBindRequest.binding_key)
  return _impl_.binding_key_.Release();
}
inline void queueBindRequest::set_allocated_binding_key(std::string* binding_key) {
  if (binding_key != nullptr) {
    
  } else {
    
  }
  _impl_.binding_key_.SetAllocated(binding_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binding_key_.IsDefault()) {
    _impl_.binding_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueBindRequest.binding_key)
}

// -------------------------------------------------------------------

// queueUnBindRequest

// string rid = 1;
inline void queueUnBindRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& queueUnBindRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueUnBindRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueUnBindRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueUnBindRequest.rid)
}
inline std::string* queueUnBindRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueUnBindRequest.rid)
  return _s;
}
inline const std::string& queueUnBindRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void queueUnBindRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.queueUnBindRequest.rid)
  return _impl_.rid_.Release();
}
inline void queueUnBindRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueUnBindRequest.rid)
}

// string cid = 2;
inline void queueUnBindRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& queueUnBindRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueUnBindRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueUnBindRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueUnBindRequest.cid)
}
inline std::string* queueUnBindRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueUnBindRequest.cid)
  return _s;
}
inline const std::string& queueUnBindRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void queueUnBindRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.queueUnBindRequest.cid)
  return _impl_.cid_.Release();
}
inline void queueUnBindRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueUnBindRequest.cid)
}

// string exchange_name = 3;
inline void queueUnBindRequest::clear_exchange_name() {
  _impl_.exchange_name_.ClearToEmpty();
}
inline const std::string& queueUnBindRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueUnBindRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueUnBindRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueUnBindRequest.exchange_name)
}
inline std::string* queueUnBindRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueUnBindRequest.exchange_name)
  return _s;
}
inline const std::string& queueUnBindRequest::_internal_exchange_name() const {
  return _impl_.exchange_name_.Get();
}
inline void queueUnBindRequest::_internal_set_exchange_name(const std::string& value) {
  
  _impl_.exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::_internal_mutable_exchange_name() {
  
  return _impl_.exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:XuMQ.queueUnBindRequest.exchange_name)
  return _impl_.exchange_name_.Release();
}
inline void queueUnBindRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_name_.IsDefault()) {
    _impl_.exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueUnBindRequest.exchange_name)
}

// string queue_name = 4;
inline void queueUnBindRequest::clear_queue_name() {
  _impl_.queue_name_.ClearToEmpty();
}
inline const std::string& queueUnBindRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.queueUnBindRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queueUnBindRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.queueUnBindRequest.queue_name)
}
inline std::string* queueUnBindRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.queueUnBindRequest.queue_name)
  return _s;
}
inline const std::string& queueUnBindRequest::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void queueUnBindRequest::_internal_set_queue_name(const std::string& value) {
  
  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::_internal_mutable_queue_name() {
  
  return _impl_.queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* queueUnBindRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:XuMQ.queueUnBindRequest.queue_name)
  return _impl_.queue_name_.Release();
}
inline void queueUnBindRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  _impl_.queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queue_name_.IsDefault()) {
    _impl_.queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.queueUnBindRequest.queue_name)
}

// -------------------------------------------------------------------

// basicPublishRequest

// string rid = 1;
inline void basicPublishRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicPublishRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicPublishRequest.rid)
}
inline std::string* basicPublishRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicPublishRequest.rid)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void basicPublishRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicPublishRequest.rid)
  return _impl_.rid_.Release();
}
inline void basicPublishRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicPublishRequest.rid)
}

// string cid = 2;
inline void basicPublishRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicPublishRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicPublishRequest.cid)
}
inline std::string* basicPublishRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicPublishRequest.cid)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void basicPublishRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicPublishRequest.cid)
  return _impl_.cid_.Release();
}
inline void basicPublishRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicPublishRequest.cid)
}

// string exchange_name = 3;
inline void basicPublishRequest::clear_exchange_name() {
  _impl_.exchange_name_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicPublishRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicPublishRequest.exchange_name)
}
inline std::string* basicPublishRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicPublishRequest.exchange_name)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_exchange_name() const {
  return _impl_.exchange_name_.Get();
}
inline void basicPublishRequest::_internal_set_exchange_name(const std::string& value) {
  
  _impl_.exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_exchange_name() {
  
  return _impl_.exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:XuMQ.basicPublishRequest.exchange_name)
  return _impl_.exchange_name_.Release();
}
inline void basicPublishRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_name_.IsDefault()) {
    _impl_.exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicPublishRequest.exchange_name)
}

// string body = 4;
inline void basicPublishRequest::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::body() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicPublishRequest.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicPublishRequest.body)
}
inline std::string* basicPublishRequest::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicPublishRequest.body)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_body() const {
  return _impl_.body_.Get();
}
inline void basicPublishRequest::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_body() {
  // @@protoc_insertion_point(field_release:XuMQ.basicPublishRequest.body)
  return _impl_.body_.Release();
}
inline void basicPublishRequest::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicPublishRequest.body)
}

// .XuMQ.BasicProperties properties = 5;
inline bool basicPublishRequest::_internal_has_properties() const {
  return this != internal_default_instance() && _impl_.properties_ != nullptr;
}
inline bool basicPublishRequest::has_properties() const {
  return _internal_has_properties();
}
inline const ::XuMQ::BasicProperties& basicPublishRequest::_internal_properties() const {
  const ::XuMQ::BasicProperties* p = _impl_.properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::XuMQ::BasicProperties&>(
      ::XuMQ::_BasicProperties_default_instance_);
}
inline const ::XuMQ::BasicProperties& basicPublishRequest::properties() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicPublishRequest.properties)
  return _internal_properties();
}
inline void basicPublishRequest::unsafe_arena_set_allocated_properties(
    ::XuMQ::BasicProperties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  _impl_.properties_ = properties;
  if (properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuMQ.basicPublishRequest.properties)
}
inline ::XuMQ::BasicProperties* basicPublishRequest::release_properties() {
  
  ::XuMQ::BasicProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XuMQ::BasicProperties* basicPublishRequest::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:XuMQ.basicPublishRequest.properties)
  
  ::XuMQ::BasicProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
  return temp;
}
inline ::XuMQ::BasicProperties* basicPublishRequest::_internal_mutable_properties() {
  
  if (_impl_.properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::XuMQ::BasicProperties>(GetArenaForAllocation());
    _impl_.properties_ = p;
  }
  return _impl_.properties_;
}
inline ::XuMQ::BasicProperties* basicPublishRequest::mutable_properties() {
  ::XuMQ::BasicProperties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicPublishRequest.properties)
  return _msg;
}
inline void basicPublishRequest::set_allocated_properties(::XuMQ::BasicProperties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties));
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicPublishRequest.properties)
}

// -------------------------------------------------------------------

// basicAckRequest

// string rid = 1;
inline void basicAckRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& basicAckRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicAckRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicAckRequest.rid)
}
inline std::string* basicAckRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicAckRequest.rid)
  return _s;
}
inline const std::string& basicAckRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void basicAckRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicAckRequest.rid)
  return _impl_.rid_.Release();
}
inline void basicAckRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicAckRequest.rid)
}

// string cid = 2;
inline void basicAckRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& basicAckRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicAckRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicAckRequest.cid)
}
inline std::string* basicAckRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicAckRequest.cid)
  return _s;
}
inline const std::string& basicAckRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void basicAckRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicAckRequest.cid)
  return _impl_.cid_.Release();
}
inline void basicAckRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicAckRequest.cid)
}

// string queue_name = 3;
inline void basicAckRequest::clear_queue_name() {
  _impl_.queue_name_.ClearToEmpty();
}
inline const std::string& basicAckRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicAckRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicAckRequest.queue_name)
}
inline std::string* basicAckRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicAckRequest.queue_name)
  return _s;
}
inline const std::string& basicAckRequest::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void basicAckRequest::_internal_set_queue_name(const std::string& value) {
  
  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_queue_name() {
  
  return _impl_.queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:XuMQ.basicAckRequest.queue_name)
  return _impl_.queue_name_.Release();
}
inline void basicAckRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  _impl_.queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queue_name_.IsDefault()) {
    _impl_.queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicAckRequest.queue_name)
}

// string msg_id = 4;
inline void basicAckRequest::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& basicAckRequest::msg_id() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicAckRequest.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicAckRequest.msg_id)
}
inline std::string* basicAckRequest::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicAckRequest.msg_id)
  return _s;
}
inline const std::string& basicAckRequest::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void basicAckRequest::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_msg_id() {
  // @@protoc_insertion_point(field_release:XuMQ.basicAckRequest.msg_id)
  return _impl_.msg_id_.Release();
}
inline void basicAckRequest::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicAckRequest.msg_id)
}

// -------------------------------------------------------------------

// basicConsumeRequest

// string rid = 1;
inline void basicConsumeRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeRequest.rid)
}
inline std::string* basicConsumeRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeRequest.rid)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void basicConsumeRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeRequest.rid)
  return _impl_.rid_.Release();
}
inline void basicConsumeRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeRequest.rid)
}

// string cid = 2;
inline void basicConsumeRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeRequest.cid)
}
inline std::string* basicConsumeRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeRequest.cid)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void basicConsumeRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeRequest.cid)
  return _impl_.cid_.Release();
}
inline void basicConsumeRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeRequest.cid)
}

// string consumer_tag = 3;
inline void basicConsumeRequest::clear_consumer_tag() {
  _impl_.consumer_tag_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::consumer_tag() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeRequest.consumer_tag)
  return _internal_consumer_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_consumer_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.consumer_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeRequest.consumer_tag)
}
inline std::string* basicConsumeRequest::mutable_consumer_tag() {
  std::string* _s = _internal_mutable_consumer_tag();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeRequest.consumer_tag)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_consumer_tag() const {
  return _impl_.consumer_tag_.Get();
}
inline void basicConsumeRequest::_internal_set_consumer_tag(const std::string& value) {
  
  _impl_.consumer_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_consumer_tag() {
  
  return _impl_.consumer_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_consumer_tag() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeRequest.consumer_tag)
  return _impl_.consumer_tag_.Release();
}
inline void basicConsumeRequest::set_allocated_consumer_tag(std::string* consumer_tag) {
  if (consumer_tag != nullptr) {
    
  } else {
    
  }
  _impl_.consumer_tag_.SetAllocated(consumer_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.consumer_tag_.IsDefault()) {
    _impl_.consumer_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeRequest.consumer_tag)
}

// string queue_name = 4;
inline void basicConsumeRequest::clear_queue_name() {
  _impl_.queue_name_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeRequest.queue_name)
}
inline std::string* basicConsumeRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeRequest.queue_name)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void basicConsumeRequest::_internal_set_queue_name(const std::string& value) {
  
  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_queue_name() {
  
  return _impl_.queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeRequest.queue_name)
  return _impl_.queue_name_.Release();
}
inline void basicConsumeRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  _impl_.queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queue_name_.IsDefault()) {
    _impl_.queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeRequest.queue_name)
}

// bool auto_ack = 5;
inline void basicConsumeRequest::clear_auto_ack() {
  _impl_.auto_ack_ = false;
}
inline bool basicConsumeRequest::_internal_auto_ack() const {
  return _impl_.auto_ack_;
}
inline bool basicConsumeRequest::auto_ack() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeRequest.auto_ack)
  return _internal_auto_ack();
}
inline void basicConsumeRequest::_internal_set_auto_ack(bool value) {
  
  _impl_.auto_ack_ = value;
}
inline void basicConsumeRequest::set_auto_ack(bool value) {
  _internal_set_auto_ack(value);
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeRequest.auto_ack)
}

// -------------------------------------------------------------------

// basicCancelRequest

// string rid = 1;
inline void basicCancelRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicCancelRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicCancelRequest.rid)
}
inline std::string* basicCancelRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicCancelRequest.rid)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void basicCancelRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicCancelRequest.rid)
  return _impl_.rid_.Release();
}
inline void basicCancelRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicCancelRequest.rid)
}

// string cid = 2;
inline void basicCancelRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicCancelRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicCancelRequest.cid)
}
inline std::string* basicCancelRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicCancelRequest.cid)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void basicCancelRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicCancelRequest.cid)
  return _impl_.cid_.Release();
}
inline void basicCancelRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicCancelRequest.cid)
}

// string consumer_tag = 3;
inline void basicCancelRequest::clear_consumer_tag() {
  _impl_.consumer_tag_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::consumer_tag() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicCancelRequest.consumer_tag)
  return _internal_consumer_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_consumer_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.consumer_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicCancelRequest.consumer_tag)
}
inline std::string* basicCancelRequest::mutable_consumer_tag() {
  std::string* _s = _internal_mutable_consumer_tag();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicCancelRequest.consumer_tag)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_consumer_tag() const {
  return _impl_.consumer_tag_.Get();
}
inline void basicCancelRequest::_internal_set_consumer_tag(const std::string& value) {
  
  _impl_.consumer_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_consumer_tag() {
  
  return _impl_.consumer_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_consumer_tag() {
  // @@protoc_insertion_point(field_release:XuMQ.basicCancelRequest.consumer_tag)
  return _impl_.consumer_tag_.Release();
}
inline void basicCancelRequest::set_allocated_consumer_tag(std::string* consumer_tag) {
  if (consumer_tag != nullptr) {
    
  } else {
    
  }
  _impl_.consumer_tag_.SetAllocated(consumer_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.consumer_tag_.IsDefault()) {
    _impl_.consumer_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicCancelRequest.consumer_tag)
}

// string queue_name = 4;
inline void basicCancelRequest::clear_queue_name() {
  _impl_.queue_name_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicCancelRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicCancelRequest.queue_name)
}
inline std::string* basicCancelRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicCancelRequest.queue_name)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void basicCancelRequest::_internal_set_queue_name(const std::string& value) {
  
  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_queue_name() {
  
  return _impl_.queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:XuMQ.basicCancelRequest.queue_name)
  return _impl_.queue_name_.Release();
}
inline void basicCancelRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  _impl_.queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queue_name_.IsDefault()) {
    _impl_.queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicCancelRequest.queue_name)
}

// -------------------------------------------------------------------

// basicConsumeResponse

// string cid = 1;
inline void basicConsumeResponse::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& basicConsumeResponse::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeResponse.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeResponse::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeResponse.cid)
}
inline std::string* basicConsumeResponse::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeResponse.cid)
  return _s;
}
inline const std::string& basicConsumeResponse::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void basicConsumeResponse::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeResponse.cid)
  return _impl_.cid_.Release();
}
inline void basicConsumeResponse::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeResponse.cid)
}

// string consumer_tag = 2;
inline void basicConsumeResponse::clear_consumer_tag() {
  _impl_.consumer_tag_.ClearToEmpty();
}
inline const std::string& basicConsumeResponse::consumer_tag() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeResponse.consumer_tag)
  return _internal_consumer_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeResponse::set_consumer_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.consumer_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeResponse.consumer_tag)
}
inline std::string* basicConsumeResponse::mutable_consumer_tag() {
  std::string* _s = _internal_mutable_consumer_tag();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeResponse.consumer_tag)
  return _s;
}
inline const std::string& basicConsumeResponse::_internal_consumer_tag() const {
  return _impl_.consumer_tag_.Get();
}
inline void basicConsumeResponse::_internal_set_consumer_tag(const std::string& value) {
  
  _impl_.consumer_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::_internal_mutable_consumer_tag() {
  
  return _impl_.consumer_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::release_consumer_tag() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeResponse.consumer_tag)
  return _impl_.consumer_tag_.Release();
}
inline void basicConsumeResponse::set_allocated_consumer_tag(std::string* consumer_tag) {
  if (consumer_tag != nullptr) {
    
  } else {
    
  }
  _impl_.consumer_tag_.SetAllocated(consumer_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.consumer_tag_.IsDefault()) {
    _impl_.consumer_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeResponse.consumer_tag)
}

// string body = 3;
inline void basicConsumeResponse::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& basicConsumeResponse::body() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeResponse.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeResponse::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicConsumeResponse.body)
}
inline std::string* basicConsumeResponse::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeResponse.body)
  return _s;
}
inline const std::string& basicConsumeResponse::_internal_body() const {
  return _impl_.body_.Get();
}
inline void basicConsumeResponse::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::release_body() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeResponse.body)
  return _impl_.body_.Release();
}
inline void basicConsumeResponse::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeResponse.body)
}

// .XuMQ.BasicProperties properties = 4;
inline bool basicConsumeResponse::_internal_has_properties() const {
  return this != internal_default_instance() && _impl_.properties_ != nullptr;
}
inline bool basicConsumeResponse::has_properties() const {
  return _internal_has_properties();
}
inline const ::XuMQ::BasicProperties& basicConsumeResponse::_internal_properties() const {
  const ::XuMQ::BasicProperties* p = _impl_.properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::XuMQ::BasicProperties&>(
      ::XuMQ::_BasicProperties_default_instance_);
}
inline const ::XuMQ::BasicProperties& basicConsumeResponse::properties() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicConsumeResponse.properties)
  return _internal_properties();
}
inline void basicConsumeResponse::unsafe_arena_set_allocated_properties(
    ::XuMQ::BasicProperties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  _impl_.properties_ = properties;
  if (properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuMQ.basicConsumeResponse.properties)
}
inline ::XuMQ::BasicProperties* basicConsumeResponse::release_properties() {
  
  ::XuMQ::BasicProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XuMQ::BasicProperties* basicConsumeResponse::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:XuMQ.basicConsumeResponse.properties)
  
  ::XuMQ::BasicProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
  return temp;
}
inline ::XuMQ::BasicProperties* basicConsumeResponse::_internal_mutable_properties() {
  
  if (_impl_.properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::XuMQ::BasicProperties>(GetArenaForAllocation());
    _impl_.properties_ = p;
  }
  return _impl_.properties_;
}
inline ::XuMQ::BasicProperties* basicConsumeResponse::mutable_properties() {
  ::XuMQ::BasicProperties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicConsumeResponse.properties)
  return _msg;
}
inline void basicConsumeResponse::set_allocated_properties(::XuMQ::BasicProperties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties));
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicConsumeResponse.properties)
}

// -------------------------------------------------------------------

// basicResponse

// string rid = 1;
inline void basicResponse::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& basicResponse::rid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicResponse.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicResponse::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicResponse.rid)
}
inline std::string* basicResponse::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicResponse.rid)
  return _s;
}
inline const std::string& basicResponse::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void basicResponse::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicResponse::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicResponse::release_rid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicResponse.rid)
  return _impl_.rid_.Release();
}
inline void basicResponse::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicResponse.rid)
}

// string cid = 2;
inline void basicResponse::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& basicResponse::cid() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicResponse.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicResponse::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuMQ.basicResponse.cid)
}
inline std::string* basicResponse::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:XuMQ.basicResponse.cid)
  return _s;
}
inline const std::string& basicResponse::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void basicResponse::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicResponse::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicResponse::release_cid() {
  // @@protoc_insertion_point(field_release:XuMQ.basicResponse.cid)
  return _impl_.cid_.Release();
}
inline void basicResponse::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuMQ.basicResponse.cid)
}

// bool ok = 3;
inline void basicResponse::clear_ok() {
  _impl_.ok_ = false;
}
inline bool basicResponse::_internal_ok() const {
  return _impl_.ok_;
}
inline bool basicResponse::ok() const {
  // @@protoc_insertion_point(field_get:XuMQ.basicResponse.ok)
  return _internal_ok();
}
inline void basicResponse::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void basicResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:XuMQ.basicResponse.ok)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace XuMQ

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
